

# はじめに
けんちょんさんの"__動的計画法超入門！ Educational DP Contest の A ～ E 問題の解説と類題集__"をみつつEduDPのA-E問題を解いた。
ので感想など

この記事は章や節ごとに書いた順番がある程度前後していたり、他の問題を解いていて気づいたことを断りなく追記していたりするので前後関係がおかしかったら、そういった思考の時間的前後があることを考慮してください。


# DP概要
そもそも __DPはDynamicProgrammingの略で動的計画法というもの__。

__１つの大きな問題を部分問題に分解し、その結果を記録しながら解いていく手法・アルゴリズム分類のこと__。

自分の感覚的に言えば __全探索を賢くしたもの__ だと思っている。

数理的にいえば、__帰納法・漸化式のプログラミング__ かな?

私は計算機科学に明るくないのでてきとーな言い方になるが

１つの大きな問題から分解された部分問題における最適解が

1. 元の大きな問題においてもその部分について最適 
2. その部分最適解を用いることで全体最適解を作り出すことができる
(逆に部分問題の最適解を用いないと全体最適解をつくりだせない)

ような構造をしているときDPを用いることができる。
このような性質を __部分構造最適性__ というようで、競プロではこの性質を見抜く、あるいはこの性質があるようにみえて無いことを見抜くというのが勝負所だったりするのだろうか。

実際にはDPの要件にはもう1つ __部分問題重複性__ というのがあるらしいが、これは元問題と部分問題がほぼ同じ問題の形をしている、さらに部分問題の部分問題も同じ形をしているというマトリョーシカのような性質を指し、これはDPを疑うようなときには自動的に成立してしまっているものなのではないだろうか。

あとなにか言うとなると、おそらくコーナーケース？(コーナーケースという単語をあまりよく理解してないが...)

部分構造最適性が綺麗に満たされているとき、部分問題を結合していく処理は非常に簡単である。しかし、単純な問題でもどこかは例外処理する必要はあると思うので(存在しないindexにたどり着くなど)そこは忘れず処理をする必要がある。
また、部分構造最適性があまり綺麗でないときは結合処理が難しくなることもあるだろう。そういう問題にはまだ出会っていない。


# 問題を解いてみて・概観
A-EまでなのでキレイなDPだけがでてくるわけで、非常に漸化式的なイメージはしやすい。問題と解き方を理解したら、あとの悩みどころはどのように書くかだろう。

DPには主に２つの書き方がある(と考えている)。それは

1. 全探索のメモ化
2. 再帰関数のメモ化

である。
私はD・E問で再帰関数実装について非常に苦心し、頭がこんがらがって途中でなにもわからなくなるぐらい混乱に陥ってしまった。最終的にD・E問で4つくらい再帰関数での実装をして少しだが混乱を抜けてきたところである。

結論からいうと、全探索メモ化をおすすめする。
全探索の個人的優位点は次のようになる

- 添字・ループの動きがわかりやすい
    - 全探索ではfor文で明確に定義するためどこの添字がどうなのか、どのような条件でループが終わるのかがわかりやすい。
    再帰関数もよくわかっていればそんなことはないのだろうが、私は再帰がいつ終わってくれるのか、どのような場合に終了処理を追記すればよいのか、どのように書くとループの終了処理になるのかということでかなり混乱した。
    今回、for文は初期条件と終了条件が明確、かつその効き方がわかりやすいとはっきり認識した。

<br>

- エラー処理がしやすい
    - 全探索だと添え字が分かりやすいと述べたが、さらにエラー処理でもこれが効いてくる。
    どのようなエラーにひっかかるのかというと、 __主にメモ用配列のインデックスを誤って、確保していない領域を指示してしまうエラー__ (だと思う)である。
    再帰関数ではインデックスがどこまで行くのかわかりづらく、複数のインデックスを用いたDPテーブルを用意するようなときには事故が多発する。
    加えて同じエラーでも再帰関数だとSegmentation faultというエラーがでてしまい、このときの対処が難しい。全探索なら標準出力をさせ、インデックスをいじったりすればおおよそメモ化配列がどうなっているかわかるが、再帰関数の中に標準出力を仕込んでもSegmentation faultとしか出てきてくれないのである。
    おそらくCプログラミング(とかg++とかx86_64とか)に詳しい人ならそうでもないのだろうが普段からオブジェクト指向もパッケージ化も知らずJupyterでPythonと戯れるだけの私のような人間にはそんな所をなんとかする力はないのである。
    こんなことをコンテスト中に解決しようとしたらあっという間に時間切れになってしまうだろうからコンパイラ型言語弱者はさっさと全探索で中に標準出力を仕込んで観察したほうが良い。(言い切り)

## 全探索と再帰関数での思考の差
全探索と再帰関数での解法を頭の中でスイッチするのがなかなかうまく行かなかったが考えていると気づいたことがあるのでメモしておく

ここ以降の章でまたなんらかの形の説明があるとおもうがDPは

__部分問題への分解・最適化・部分問題の結合__

という３プロセスで解いていく、しかし全探索と再帰関数とでコードの上に現れるプロセスが違うことが分かった

以降３プロセスを　__分解・部分最適化・結合__ と呼ぶ

### 全探索
具体例として次のようなものが全探索のコア部分になる

```cpp
    for (int i = 0; i < n; ++i)
    {
        for (int sum_w = 0; sum_w <= w; ++sum_w)
        {
            if(sum_w-weight[i]>=0)
                chmax(dp[i+1][sum_w],dp[i][sum_w-weight[i]]+value[i]);
            chmax(dp[i+1][sum_w],dp[i][sum_w]);
        }
    }
```

コード上には実は分解プロセスが表れていない
これはfor文になった時点で分解はすでに済んでいるからだ。

全探索ではイテレータiの周回でdp[i+1]を更新している
これが可能なのは、すでに元問題が完全に分解されているからだ

完全に分解されているから、最小の部分問題i=0から出発する。i=0の最適化はほぼ初期値のことであるのですでに解けている。
するとi=1はi=0のメモ結果からO(w)で解ける。ということはコードの上で二重for文に成っていることからもわかるだろう。以降、これの繰り返しである。

したがって全探索型のコードは元問題の分解はコードには表れていないのである。
__最適化・結合__ の２プロセスに吸収されて表現されている、というあたりで考えるのが妥当かな？

### 再帰関数
同じ問題での再帰関数のコードを示す

```cpp
/*
    品0-iまでで重量sum_wとなるときの最大価値をdpに保存
    return でdp[i][sum_w]　を返すことで部分問題に分解する

    solveに際してはrec(N-1,W)で用いて解を返す
    (0indexなので品番は0-N-1)
 */
ll rec(int i,int sum_w)
{
    //負の品番は存在しないので価値0でリターン
    if(i==-1 ) return 0;

    //探索済みならそのまま返す
    if(dp[i][sum_w]!=-1) return dp[i][sum_w];

    ll res;
    //重量的に品iを選択できるとき
    if(sum_w-weight[i]>=0)
    {
        /*
            (i非選択)品i-1まででsum_w以下最大価値と
            (i選択)品i-1まででsum_w-weight[i]以下の最大価値+品iの価値
            の比較をして大きい方を取る
         */
        res=max(rec(i-1,sum_w),rec(i-1,sum_w-weight[i])+value[i]);
    }
    /*
        品iを選ぶ重量的余裕がなければ
        (i非選択)品i-1まででsum_w以下最大価値
        のみとりうる
    */
    else res=rec(i-1,sum_w);

    return dp[i][sum_w]=res;


}

//solveではrec(N-1,W) で解を返す
```

rec(0,0)で解を返すような積み上げ型の再帰も可能だが、自分の理解のために配るタイプの再帰を掲載した。

再帰のコードを見ると
```cpp
res=max(rec(i-1,sum_w),rec(i-1,sum_w-weight[i])+value[i]);
```

のように、元問題がrecに渡されてスタートし、徐々により小さい部分問題に引数が渡されていく。

そして最小部分問題にたどり着くとそこからはreturnで部分最適化の結果が返ってきて、1段大きい部分問題の最適化が行われ、その結果が...

というふうにして元問題の最適化がなされることがわかる

このコードからのプロセス解説でも再帰関数でのコードには明らかに __分解・部分最適化・結合__ の3プロセスが明瞭に表れている事がわかる

### 両者を見比べて
なんとなく良いところを突けたのではないかと少し満足している
どちらを選ぶかは個人の得意な思考プロセス次第でいいと思うのだが私のようなどっちつかずはどちらも対して楽には感じないのでこのように現れる思考・解法プロセスがわかっていると書きやすいと思うし、問題によっては片方のほうが書きやすいこともあるかもしれない。
ただ関数で書かない分単純には全探索のほうが簡単かな？


# 各問

## A・B Frog
DPの解説でよく出てくる問題だと思う。ぴょんぴょんするのがカエルだったりウサギだったり...

Aは明らかにBの前段問題なので一括で取り扱う。

まずDPを使うなら次のアイテムをおいておこう

```cpp
template<class T> inline bool chmin(T& a, T b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

template<class T> inline bool chmax(T& a, T b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

const long long INF=1LL<<60;
```

chmin(or chmax)は２つの引数を比較して小さい(大きい)方を第一引数に代入する関数。min or maxは問題の目的が最大・最小化のどちらなのかで判断する。

INFは最小化問題においてはメモ化配列における未探索を表現する値である。-INFにすれば最大化でも使えるとは思うが、正数だけがでてくる場合にはINFの代わりに-1をつかっておけば

```cpp
#include <string.h>
memset(dp, -1, sizeof(dp));
```
で一発でメモ化配列dpに全代入できる。-1 以外ではできない。
このようにありえない数字、選択肢たりえない数字を最初においておくことでchmin or chmaxが正しく機能し、全探索を淀みなく行うことが可能になる。 

では与えられる定数を見てみよう
- 足場の数N
- １度に可能な足場移動個数K
- 各足場の高さh_i

以上

移動コストについては現在地をi,移動個数をkとすると$|h_i-h_{i+k}|$で表現される。
では、１から出てNまで行く最小コストはいくつか？(ゼロインデックスでなら0 ~ N-1)

さてあまりよろしくないがDPで解くことがわかっているのでDP的視点で見てみよう
元となる問題は上記の通り、そこから部分問題を考えてみよう。途中の足場を表す適当な変数subをおく。すると部分問題は

- 1から出てsubまで行く最小コストはいくつか

明らかに、sub=1~Nでどれも問題の形が同じである。部分問題重複性はあるといえる。

では部分構造最適性はどうだろうか。次の２点を思い出そう

1. 部分問題も同じ最適化問題が成立している
2. 部分問題間が独立している

ちょうどNにたどり着く1step前を考えてみる
すると、N-K,N-(K-1),...,N-1からK~1個移動によってちょうど1stepの移動でNに到着できる。

ではこのときの最小コストはどのようにあらわされるかを考えると

```
min=
({
    (N-Kまでの最小コスト)+|h[N-K]-h[N]|,
    (N-(K-1)までの最小コスト)+|h[N-(K-1)]-h[N]|,
    ...,
    (N-1までの最小コスト)+|h[N-1]-h[N]|
})
```

となるはずである。ポイントはmin候補のどれもが各足場での最小コストを仮定しているという点である。
これほど単純な問題であれば明らかではあるが、この候補式はN以外の足場にたどり着く場合ついても全く同様である。

ではsubまでの部分問題を候補式を使わない場合はどのように解くかというと１~ subの全探索を行うことになる。これもsubが1~Nのどれでも全く同じことが言える。

したがって、どこを切り取った部分問題についても同じ最適化問題が成立している。
こうして上記１が成立しているため、Nまでの最小コストを知るにはN-K ~ N-1それぞれまでの最小コストがわかっていればO(K)で解くことができ、また各N-k ~ N-1についても...と繰り返すことができるのである。

そして部分問題の最小コストがわかっていれば〜というのがメモ化のコアである。

計算量は、各足場につき、高々K通りの遷移が考えられるためO(NK)である。
DPの計算量はノード数Vとエッジ数EからO(V+E)でほぼ求まるということらしく。この問で考えるとノードはN、エッジはノードNと遷移が高々KでNK以下であるためO(N+NK)からO(NK)とたしかに求められる。

構造最適性の２の独立性について今回は、各移動方法で同じ足場は決して複数回登場しない、ということがかかっている。





## C Vacation


## D・E Knapsack