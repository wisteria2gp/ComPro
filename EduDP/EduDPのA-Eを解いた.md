

# はじめに
けんちょんさんの"__動的計画法超入門！ Educational DP Contest の A ～ E 問題の解説と類題集__"をみつつEduDPのA-E問題を解いた。
ので感想など


# DP概要
そもそも __DPはDynamicProgrammingの略で動的計画法というもの__。

__１つの大きな問題を部分問題に分解し、その結果を記録しながら解いていく手法・アルゴリズム分類のこと__。

自分の感覚的に言えば __全探索を賢くしたもの__ だと思っている。

数理的にいえば、__帰納法・漸化式のプログラミング__ かな?

私は計算機科学に明るくないのでてきとーな言い方になるが

１つの大きな問題から分解された部分問題における最適解が

1. 元の大きな問題においてもその部分について最適 
2. その部分最適解を用いることで全体最適解を作り出すことができる
(逆に部分問題の最適解を用いないと全体最適解をつくりだせない)

ような構造をしているときDPを用いることができる。
このような性質を __部分構造最適性__ というようで、競プロではこの性質を見抜く、あるいはこの性質があるようにみえて無いことを見抜くというのが勝負所だったりするのだろうか。

実際にはDPの要件にはもう1つ __部分問題重複性__ というのがあるらしいが、これは元問題と部分問題がほぼ同じ問題の形をしている、さらに部分問題の部分問題も同じ形をしているというマトリョーシカのような性質を指し、これはDPを疑うようなときには自動的に成立してしまっているものなのではないだろうか。

あとなにか言うとなると、おそらくコーナーケース？(コーナーケースという単語をあまりよく理解してないが...)

部分構造最適性が綺麗に満たされているとき、部分問題を結合していく処理は非常に簡単である。しかし、単純な問題でもどこかは例外処理する必要はあると思うので(存在しないindexにたどり着くなど)そこは忘れず処理をする必要がある。
また、部分構造最適性があまり綺麗でないときは結合処理が難しくなることもあるだろう。そういう問題にはまだ出会っていない。


# 問題を解いてみて・概観
A-EまでなのでキレイなDPだけがでてくるわけで、非常に漸化式的なイメージはしやすい。問題と解き方を理解したら、あとの悩みどころはどのように書くかだろう。

DPには主に２つの書き方がある(と考えている)。それは

1. 全探索のメモ化
2. 再帰関数のメモ化

である。
私はD・E問で再帰関数実装について非常に苦心し、頭がこんがらがって途中でなにもわからなくなるぐらい混乱に陥ってしまった。最終的にD・E問で4つくらい再帰関数での実装をして少しだが混乱を抜けてきたところである。

結論からいうと、全探索メモ化をおすすめする。
全探索の個人的優位点は次のようになる

- 添字・ループの動きがわかりやすい
    - 全探索ではfor文で明確に定義するためどこの添字がどうなのか、どのような条件でループが終わるのかがわかりやすい。
    再帰関数もよくわかっていればそんなことはないのだろうが、私は再帰がいつ終わってくれるのか、どのような場合に終了処理を追記すればよいのか、どのように書くとループの終了処理になるのかということでかなり混乱した。
    今回、for文は初期条件と終了条件が明確、かつその効き方がわかりやすいとはっきり認識した。

<br>

- エラー処理がしやすい
    - 全探索だと添え字が分かりやすいと述べたが、さらにエラー処理でもこれが効いてくる。
    どのようなエラーにひっかかるのかというと、 __主にメモ用配列のインデックスを誤って、確保していない領域を指示してしまうエラー__ (だと思う)である。
    再帰関数ではインデックスがどこまで行くのかわかりづらく、複数のインデックスを用いたDPテーブルを用意するようなときには事故が多発する。
    加えて同じエラーでも再帰関数だとSegmentation faultというエラーがでてしまい、このときの対処が難しい。全探索なら標準出力をさせ、インデックスをいじったりすればおおよそメモ化配列がどうなっているかわかるが、再帰関数の中に標準出力を仕込んでもSegmentation faultとしか出てきてくれないのである。
    おそらくCプログラミング(とかg++とかx86_64とか)に詳しい人ならそうでもないのだろうが普段からオブジェクト指向もパッケージ化も知らずJupyterでPythonと戯れるだけの私のような人間にはそんな所をなんとかする力はないのである。
    こんなことをコンテスト中に解決しようとしたらあっという間に時間切れになってしまうだろうからコンパイラ型言語弱者はさっさと全探索で中に標準出力を仕込んで観察したほうが良い。(言い切り)


# 各問

## A・B Frog
DPの解説でよく出てくる問題だと思う。ぴょんぴょんするのがカエルだったりウサギだったり...

Aは明らかにBの前段問題なので一括で取り扱う。

まずDPを使うなら次のアイテムをおいておこう

```cpp
template<class T> inline bool chmin(T& a, T b) {
    if (a > b) {
        a = b;
        return true;
    }
    return false;
}

template<class T> inline bool chmax(T& a, T b) {
    if (a < b) {
        a = b;
        return true;
    }
    return false;
}

const long long INF=1LL<<60;
```

chmin(or chmax)は２つの引数を比較して小さい(大きい)方を第一引数に代入する関数。min or maxは問題の目的が最大・最小化のどちらなのかで判断する。

INFは最小化問題においてはメモ化配列における未探索を表現する値である。-INFにすれば最大化でも使えるとは思うが、正数だけがでてくる場合にはINFの代わりに-1をつかっておけば

```cpp
#include <string.h>
memset(dp, -1, sizeof(dp));
```
で一発でメモ化配列dpに全代入できる。-1 以外ではできない。
このようにありえない数字、選択肢たりえない数字を最初においておくことでchmin or chmaxが正しく機能し、全探索を淀みなく行うことが可能になる。 

では与えられる定数を見てみよう
- 足場の数N
- １度に可能な足場移動個数K
- 各足場の高さh_i

以上

移動コストについては現在地をi,移動個数をkとすると$|h_i-h_{i+k}|$で表現される。
では、１から出てNまで行く最小コストはいくつか？(ゼロインデックスでなら0 ~ N-1)

さてあまりよろしくないがDPで解くことがわかっているのでDP的視点で見てみよう
元となる問題は上記の通り、そこから部分問題を考えてみよう。途中の足場を表す適当な変数subをおく。すると部分問題は

- 1から出てsubまで行く最小コストはいくつか

明らかに、sub=1~Nでどれも問題の形が同じである。部分問題重複性はあるといえる。

では部分構造最適性はどうだろうか。次の２点を思い出そう

1. 部分問題も同じ最適化問題が成立している
2. 部分問題間が独立している

ちょうどNにたどり着く1step前を考えてみる
すると、N-K,N-(K-1),...,N-1からK~1個移動によってちょうど1stepの移動でNに到着できる。

ではこのときの最小コストはどのようにあらわされるかを考えると

```
min=
({
    (N-Kまでの最小コスト)+|h[N-K]-h[N]|,
    (N-(K-1)までの最小コスト)+|h[N-(K-1)]-h[N]|,
    ...,
    (N-1までの最小コスト)+|h[N-1]-h[N]|
})
```

となるはずである。ポイントはmin候補のどれもが各足場での最小コストを仮定しているという点である。
これほど単純な問題であれば明らかではあるが、この候補式はN以外の足場にたどり着く場合ついても全く同様である。

ではsubまでの部分問題を候補式を使わない場合はどのように解くかというと１~ subの全探索を行うことになる。これもsubが1~Nのどれでも全く同じことが言える。

したがって、どこを切り取った部分問題についても同じ最適化問題が成立している。
こうして上記１が成立しているため、Nまでの最小コストを知るにはN-K ~ N-1それぞれまでの最小コストがわかっていればO(K)で解くことができ、また各N-k ~ N-1についても...と繰り返すことができるのである。

そして部分問題の最小コストがわかっていれば〜というのがメモ化のコアである。

計算量は、各足場につき、高々K通りの遷移が考えられるためO(NK)である。
DPの計算量はノード数Vとエッジ数EからO(V+E)でほぼ求まるということらしく。この問で考えるとノードはN、エッジはノードNと遷移が高々KでNK以下であるためO(N+NK)からO(NK)とたしかに求められる。

構造最適性の２の独立性について今回は、各移動方法で同じ足場は決して複数回登場しない、ということがかかっている。





## C Vacation


## D・E Knapsack